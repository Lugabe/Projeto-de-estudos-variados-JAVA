package bytebankHerdadoContaUtilTeste;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import bytebankHerdadoContaModelo.Cliente;
import bytebankHerdadoContaModelo.Conta;
import bytebankHerdadoContaModelo.ContaCorrente;
import bytebankHerdadoContaModelo.ContaPoupanca;

public class Test {

	public static void main(String[] args) throws Exception {

		/**
		 * Lancei na assinatura do metodo main uma throws Excepetion, avisando que é um
		 * metodo pontecialmente perigoso e que pode ocorrer qualquer tipo de Exception.
		 * 
		 * 
		 * Neste projeto de estudo, foram instanciadas 4 contas bancarias com os seus
		 * titulares, e depois fiz a organização da conta com o número menor para a
		 * conta com o numero maior.
		 * 
		 * Depois fiz a organização pelo nome dos titulares em ordem alfabetica A a Z.
		 * 
		 * Neste projeto foi utilizado polimorfimo, Herança, Exception, ArrayList,
		 * Wrappers, e interfaces.
		 * 
		 * Bibliotecas utilizadas: Java.Util.ArrayList, Java.Lang
		 * 
		 * @author Luis_Gabriel_Bernardi
		 */

		Conta cc1 = new ContaCorrente(22, 33);
		Cliente clienteCC1 = new Cliente();
		clienteCC1.setNome("Nico");
		cc1.setTitular(clienteCC1);
		cc1.deposita(333.0);
		
		try {
			throw new NullPointerException("Testando uma Exception!");
		} catch (ArithmeticException | NullPointerException ex) {
			ex.getStackTrace();
		} finally {
			System.out.println("Testando um finally");
		}

		/**
		 * Aqui eu simulei um lançamento de uma Exception e também usei o try-catch
		 * para tratar a exception.
		 * 
		 * @author Luis_Gabriel_Bernardi
		 */

		Conta cc2 = new ContaPoupanca(22, 44);
		Cliente clienteCC2 = new Cliente();
		clienteCC2.setNome("Guilherme");
		cc2.setTitular(clienteCC2);
		cc2.deposita(444.0);

		Conta cc3 = new ContaCorrente(22, 11);
		Cliente clienteCC3 = new Cliente();
		clienteCC3.setNome("Paulo");
		cc3.setTitular(clienteCC3);
		cc3.deposita(111.0);

		Conta cc4 = new ContaPoupanca(22, 22);
		Cliente clienteCC4 = new Cliente();
		clienteCC4.setNome("Ana");
		cc4.setTitular(clienteCC4);
		cc4.deposita(222.0);

		List<Conta> lista = new ArrayList<>();
		lista.add(cc1);
		lista.add(cc2);
		lista.add(cc3);
		lista.add(cc4);

		System.out.println("-------------------------------------------SEM ORGANIZAÇÃO");
		for (Conta conta : lista) {
			System.out.println(conta);
		}

		//Instanciando a classe do comparador do numero da conta
		NumeroDaContaComparator comparator = new NumeroDaContaComparator();

		System.out.println("-------------------------------------------NUMERO ORGANIZADO");

		lista.sort(comparator);

		for (Conta conta : lista) {
			System.out.println(conta);
		}

		System.out.println("-------------------------------------------NOME ORGANIZADO");
		
		//Instanciando a classe do comparador do nome do cliente
		
		lista.sort(new TitularDaContaComparator());

		for (Conta conta : lista) {
			System.out.println(conta + ", " + conta.getTitular().getName());
		}
		
		//lista.sort(null); Comparando pela ordem natural.( de acordo com a sequencia)
		//dos numeros
	}

}

/**
 * Criando uma classe dentro da outra classe, para implementar o metodo da
 * interface Comparator, na qual ira realizar a comparaçao entre numeros de
 * contas e nomes de clientes.
 * 
 * @author Luis_Gabriel_Bernardi
 *
 */

//criando uma classe que iria comparar duas Strings e ordenar em ordem alfabetica.
class TitularDaContaComparator implements Comparator<Conta> {

	@Override
	public int compare(Conta c1, Conta c2) {

		String nameC1 = c1.getTitular().getName();
		String nameC2 = c2.getTitular().getName();

		return nameC1.compareTo(nameC2);
	}

}

//criando a classe que ira validar se o numero de uma conta é menor do que a outra
class NumeroDaContaComparator implements Comparator<Conta> {

	@Override
	public int compare(Conta c1, Conta c2) {

		if (c1.getNumero() < c2.getNumero()) {
			return -1;
		}

		if (c1.getNumero() > c2.getNumero()) {
			return 1;
		}

		return 0;
	}
}
